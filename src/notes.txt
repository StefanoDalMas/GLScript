belief set:
    come viene popolato?
    - pusho nel belief set tutti i pacchetti che vedo che non sono presi su
belife revision(solo info su pacchetti per ora):
    - prendo dalle opzioni totali quella migliore in base a:
        + TODO (punteggio, distanza[aerea, manattan, astar?])
    - pusho/faccio l'intenzione che ho deciso essere migliore

while(1)
intention set:
    In questa dobbiamo capire quali intenzioni pushre nel set.
    - pusho put down quando ... TODO (tipo num pacchetti e valore)
    - pusho random move quando non ho altri obiettivi da fare
intention revision: (idealmente non conti pesanti)
    - leggo l'intenzione e valuto se è ancora fattibile
        + pick up: guardo se c'è ancora e se ha ancora un valore interessante (magari logica con time-stamp -> pushare nella coda di intenzioni anche quando è stata pushata)
        + put down: no controlli
        + go to: no controlli, ma non lo pushamo mai. Lo usiamo solo come subIntention
        + random move: no controllo

intentions implementations:
    + pick up: prova a prendere il pacchetto che c'è scritto nell'intenzione. Se si blocca, l'intenzione finisce.
    + put down: provo ad andare nel punto di consegna. Se mi blocco, vado in un'altro punto di consegna (in base a qualche distanza). Se non riesco neanche li, finisce senza buttar giu.
    + go to: vado dove mi viene detto prendendo su i pacchi per strada e buttando giù se passo per un punto di consegna
    + random move: sceglie tile camminabile a distanza 1 e ci va (con astar ma l'è stesso)

TODO NOW

- Features : 
    - capire perchè fanno l'exchange solo se si vedono
    - fixare PDDL che crasha
    - corner case dell'angolo

    Strategie "anti-agent":
        - brute force agli altri agenti(?) + 1 esame
        - slave fa blocking se non ha niente da fare(?)

- Planner : 
    - rendere funzioni il codice che è copiato nei plan(vedi PDDLMove...)
    - se fallisce il plan vedere che accade quando faccio la setImmediate(loop infinito su IntentionRevision)


fine

belief set -> dove sono i pacchetti che ho visto
astar percorso che è sequenza di posizioni





//New AtomicExchange
class AtomicExchange extends Plan {
    static isApplicableTo(atomic_exchange, x, y, hasToDrop) {
        return atomic_exchange == 'atomic_exchange';
    }
    async execute(atomic_exchange, x, y, hasToDrop) {
        //we never check if (this.stopped) throw ['stopped']; because we cannot preempt this plan



        let allyLocation;
        let goToMiddlePointCounter = 0;
        let arrived = false;
        while (goToMiddlePointCounter < consts.MAX_PLAN_TRIES && (client.beliefSet.me.x != x || client.beliefSet.me.y != y) && !arrived) {
            let neighbors = client.beliefSet.deliveroo_graph.neighbors(client.beliefSet.deliveroo_graph.grid[client.beliefSet.me.x][client.beliefSet.me.y]);
            if (neighbors.some(node => node.x === x && node.y === y)) {
                arrived = true;
            }
            // //find if my ally is what is blocking me
            // for (let ally of client.allyList) {
            //     for (let neighbour of neighbors) {
            //         let myAlly = client.beliefSet.agentsLocations.get(ally.id);
            //         if (myAlly) {
            //             if (neighbour.x === myAlly.x && neighbour.y === myAlly.y) {
            //                 allyFound = true;
            //                 allyLocation = { x: Math.round(myAlly.x), y: Math.round(myAlly.y) };
            //             }
            //         }
            //     }
            // }
            let status = await this.subIntention(['go_to', x, y]);
            goToMiddlePointCounter++;
        }
        if (goToMiddlePointCounter >= consts.MAX_PLAN_TRIES) {
            //for each ally in the list of allies
            for (let ally of client.allyList) {
                // consts.deliveryingAfterCollaboration = false;
                await client.deliverooApi.say(ally, new Message("fail", client.secretToken, "Can't reach the middle point, exiting plan!"));
            }
            return false;
        }
        if (client.beliefSet.me.x === x && client.beliefSet.me.y === y) {
            let allyFound = false;
            let ts = Date.now();
            while (!allyFound) {
                for (let ally of client.allyList) {
                    let myAlly = client.beliefSet.agentsLocations.get(ally.id);
                    let me_x = Math.round(client.beliefSet.me.x);
                    let me_y = Math.round(client.beliefSet.me.y);
                    let neighbors = client.beliefSet.deliveroo_graph.neighbors(client.beliefSet.deliveroo_graph.grid[me_x][me_y]);
                    for (let neighbour of neighbors) {
                        if (neighbour) {
                            if (myAlly.x === neighbour.x && myAlly.y === neighbour.y) {
                                allyFound = true;
                                allyLocation = { x: Math.round(myAlly.x), y: Math.round(myAlly.y) };
                            }
                        }
                    }
                }
                await sleep(100);
                if(Date.now() - ts > 3000){
                    for (let ally of client.allyList) {
                        await client.deliverooApi.say(ally.id, new Message("fail", client.secret, "Waited too long"));
                    }
                    return false;
                }
            }
            await sleep(300);
            console.log("Ally adjacent!");
        } else { //if ((client.beliefSet.me.x !== x || client.beliefSet.me.y !== y))
            let allyFound = false;
            let ts = Date.now();
            while (!allyFound) {
                for (let ally of client.allyList) {
                    let myAlly = client.beliefSet.agentsLocations.get(ally.id);
                    let me_x = Math.round(client.beliefSet.me.x);
                    let me_y = Math.round(client.beliefSet.me.y);
                    let neighbors = client.beliefSet.deliveroo_graph.neighbors(client.beliefSet.deliveroo_graph.grid[me_x][me_y]);
                    for (let neighbour of neighbors) {
                        if (neighbour) {
                            if (myAlly.x === neighbour.x && myAlly.y === neighbour.y) {
                                allyFound = true;
                                allyLocation = { x: Math.round(myAlly.x), y: Math.round(myAlly.y) };
                            }
                        }
                    }
                }
                await sleep(100);
                if(Date.now() - ts > 3000){
                    for (let ally of client.allyList) {
                        await client.deliverooApi.say(ally.id, new Message("fail", client.secret, "Waited too long"));
                    }
                    return false;
                }
            }
            await sleep(300);
            console.log("Adjacent on site!");
            if (false) {
                for (let ally of client.allyList) {
                    await client.deliverooApi.say(ally.id, new Message("fail", client.secret, "Who is there!?"));
                }
                return false;
            }
        }
        //now they are both near to each other, we can start the exchange
        if (hasToDrop) {

            let status = await client.deliverooApi.putdown();
            let me_x = Math.round(client.beliefSet.me.x);
            let me_y = Math.round(client.beliefSet.me.y);
            client.beliefSet.parcelLocations[me_x][me_y] = { location: 0, id: undefined };
            if (status) {
                client.beliefSet.me.parcels_on_head = 0;
            }
            let direction = '';
            if (allyLocation.x === me_x + 1 && allyLocation.y === me_y) {
                direction = 'left';
            } else if (allyLocation.x === me_x - 1 && allyLocation.y === me_y) {
                direction = 'right';
            } else if (allyLocation.x === me_x && allyLocation.y === me_y + 1) {
                direction = 'down';
            } else if (allyLocation.x === me_x && allyLocation.y === me_y - 1) {
                direction = 'up';
            }
            await client.deliverooApi.move(direction);
            await sleep(500);
            // consts.atomic_exchange_in_queue = false;
        } else {
            let direction = '';
            let me_x = Math.round(client.beliefSet.me.x);
            let me_y = Math.round(client.beliefSet.me.y);
            if (allyLocation.x === me_x + 1 && allyLocation.y === me_y) {
                direction = 'right';
            } else if (allyLocation.x === me_x - 1 && allyLocation.y === me_y) {
                direction = 'left';
            } else if (allyLocation.x === me_x && allyLocation.y === me_y + 1) {
                direction = 'up';
            } else if (allyLocation.x === me_x && allyLocation.y === me_y - 1) {
                direction = 'down';
            }
            let moved = false;
            while (!moved) {
                moved = await client.deliverooApi.move(direction);
            }
            client.beliefSet.me.x = Math.round(moved.x);
            client.beliefSet.me.y = Math.round(moved.y);
            await client.deliverooApi.pickup();
            client.beliefSet.parcelLocations[me_x][me_y] = { location: 0, id: undefined };
            let closestDelivery = findBestTile(client.beliefSet.delivery_tiles);
            if (closestDelivery === undefined) {
                for (let allyId of client.allyList) {
                    await client.deliverooApi.say(allyId, new Message("fail", client.secretToken, "No delivery tiles found"));
                }
                return false;
            }
            await this.subIntention(['go_put_down', closestDelivery[0], closestDelivery[1]]);
            for (let allyId of client.allyList) {
                await client.deliverooApi.say(allyId, new Message("AtomicExchangeFinished", client.secretToken, "Atomic Exchange Finished!"));
            }

        }
        return true;
    }
}